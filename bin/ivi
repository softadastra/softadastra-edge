#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Robust Composer autoloader discovery
 * - Local project:   <project>/vendor/autoload.php
 * - Package vendor:  ~/.config/composer/vendor/autoload.php  (Composer v2)
 * - Legacy vendor:   ~/.composer/vendor/autoload.php          (Composer v1)
 * - Fallback:        ../../autoload.php (in case of vendor/bin symlink)
 */
$autoloadCandidates = [
    __DIR__ . '/../vendor/autoload.php',                     // package-local (create-project)
    dirname(__DIR__, 2) . '/vendor/autoload.php',            // vendor/bin/ivi -> ../../vendor/autoload.php
    getenv('COMPOSER_HOME') ? rtrim((string) getenv('COMPOSER_HOME'), '/') . '/vendor/autoload.php' : null, // composer v2
    isset($_SERVER['HOME']) ? rtrim((string) $_SERVER['HOME'], '/') . '/.config/composer/vendor/autoload.php' : null, // composer v2 default
    isset($_SERVER['HOME']) ? rtrim((string) $_SERVER['HOME'], '/') . '/.composer/vendor/autoload.php' : null, // composer v1 default
];
$autoload = null;
foreach ($autoloadCandidates as $c) {
    if ($c && is_file($c)) {
        $autoload = $c;
        break;
    }
}
if (!$autoload) {
    fwrite(STDERR, "[ERROR] Could not locate Composer autoload.php\n");
    exit(1);
}
require $autoload;

use Ivi\Core\Console\CommandRunner;
use Ivi\Core\Migrations\Migrator;
use Ivi\Core\Seeds\SeederRunner;

/**
 * Discover module migration paths and (optionally) let modules register config.
 *
 * Returns an array of existing migration directories, e.g.:
 * [
 *   /.../scripts/migrations,
 *   /.../modules/Market/Core/database/migrations,
 *   /.../modules/Blog/Core/database/migrations,
 * ]
 */
function ivi_cli_module_migration_paths(string $baseDir): array
{
    $configFile  = $baseDir . '/config/modules.php';
    $modulesCfg  = is_file($configFile) ? require $configFile : ['modules' => []];
    $modulesList = $modulesCfg['modules'] ?? [];

    $paths = [];

    // (1) Always include global migrations if present
    $global = $baseDir . '/scripts/migrations';
    if (is_dir($global)) {
        $paths[] = $global;
    }

    // (2) Load each Module.php (returns an instance) and call register()
    $modules = [];
    foreach ($modulesList as $slug) {
        $moduleFile = $baseDir . "/modules/{$slug}/Module.php";
        if (is_file($moduleFile)) {
            /** @var \App\Modules\ModuleContract $m */
            $m = require $moduleFile;
            $modules[] = $m;
        }
    }
    foreach ($modules as $m) {
        try {
            $m->register(); // safe pre-boot config merge/binds
        } catch (\Throwable $e) {
            // keep CLI resilient
        }
    }

    // (3) Collect each module's migrations folder if it exists
    foreach ($modulesList as $slug) {
        $mig = $baseDir . "/modules/{$slug}/database/migrations";
        if (is_dir($mig)) {
            $paths[] = $mig;
        }
    }

    // De-dupe while preserving order
    return array_values(array_unique($paths));
}

/**
 * Discover seeder paths for global app and modules.
 *
 * Returns an ordered list of existing directories, e.g.:
 * [
 *   /.../scripts/seeders,
 *   /.../modules/Market/Core/database/seeders,
 *   /.../modules/Blog/Core/database/seeders,
 * ]
 */
function ivi_cli_module_seeder_paths(string $baseDir): array
{
    $configFile  = $baseDir . '/config/modules.php';
    $modulesCfg  = is_file($configFile) ? require $configFile : ['modules' => []];
    $modulesList = $modulesCfg['modules'] ?? [];

    $paths = [];

    // (1) Global seeders (optional)
    $global = $baseDir . '/scripts/seeders';
    if (is_dir($global)) {
        $paths[] = $global;
    }

    // (2) Module seeders
    foreach ($modulesList as $slug) {
        $seed = $baseDir . "/modules/{$slug}/database/seeders";
        if (is_dir($seed)) {
            $paths[] = $seed;
        }
    }

    // De-dupe while preserving order
    return array_values(array_unique($paths));
}

final class CliBootstrap
{
    private static function badge(string $label, string $color): string
    {
        $colors = [
            'red'    => "\033[1;31m",
            'green'  => "\033[1;32m",
            'yellow' => "\033[1;33m",
            'blue'   => "\033[1;34m",
            'cyan'   => "\033[1;36m",
            'gray'   => "\033[0;37m",
            'reset'  => "\033[0m",
        ];
        $start = $colors[$color] ?? $colors['reset'];
        $end   = $colors['reset'];
        return sprintf("[%s%s%s]", $start, strtoupper($label), $end);
    }

    public static function run(array $argv): void
    {
        $cmd = $argv[1] ?? null;

        // ivi new <name>
        if ($cmd === 'new') {
            $name = $argv[2] ?? null;
            if (!$name) {
                echo self::badge('ERROR', 'red') . " Missing project name.\n";
                echo self::badge('INFO', 'yellow') . " Usage: ivi new <project-name>\n";
                exit(1);
            }

            echo self::badge('IVI', 'cyan') . " Creating new project: {$name}\n";
            $cmdLine = sprintf('composer create-project iviphp/ivi %s', escapeshellarg($name));
            passthru($cmdLine, $code);

            if ($code === 0) {
                echo self::badge('DONE', 'green') . " Project '{$name}' created!\n";
                echo self::badge('TIP', 'yellow') . " Next:\n  cd {$name}\n  composer serve\n";
            } else {
                echo self::badge('ERROR', 'red') . " Creation failed (code {$code}).\n";
            }
            exit($code);
        }

        // Seed (global + modules)
        if (in_array($cmd, ['seed', 'db:seed'], true)) {
            $baseDir = realpath(__DIR__ . '/..') ?: dirname(__DIR__);

            $paths = ivi_cli_module_seeder_paths($baseDir);
            if (!$paths) {
                echo self::badge('INFO', 'yellow') . " No seeder paths found.\n";
                exit(0);
            }

            foreach ($paths as $path) {
                echo self::badge('IVI', 'cyan') . " Seed Path: {$path}\n";
                try {
                    (new SeederRunner($path))->run();
                } catch (\Throwable $e) {
                    echo self::badge('ERROR', 'red') . " {$e->getMessage()}\n";
                    exit(1);
                }
                echo "\n";
            }
            exit(0);
        }

        // Intercept migration commands: run global + module migrations
        if (in_array($cmd, ['migrate', 'migrate:status', 'migrate:reset'], true)) {
            $baseDir = realpath(__DIR__ . '/..') ?: dirname(__DIR__);

            $paths = ivi_cli_module_migration_paths($baseDir);
            if (!$paths) {
                echo self::badge('INFO', 'yellow') . " No migration paths found.\n";
                exit(0);
            }

            foreach ($paths as $path) {
                echo self::badge('IVI', 'cyan') . " Path: {$path}\n";
                $migrator = new Migrator($path);

                switch ($cmd) {
                    case 'migrate':
                        $migrator->migrate();
                        break;
                    case 'migrate:status':
                        $migrator->status();
                        break;
                    case 'migrate:reset':
                        $migrator->reset();
                        break;
                }
                echo "\n";
            }
            exit(0);
        }

        // modules:publish-assets [--copy] [--force]
        if ($cmd === 'modules:publish-assets') {
            $baseDir = realpath(__DIR__ . '/..') ?: dirname(__DIR__);
            $modsDir = $baseDir . '/modules';
            $pubRoot = $baseDir . '/public/modules';
            $copy    = in_array('--copy', $argv, true);
            $force   = in_array('--force', $argv, true);

            $isWindows = (DIRECTORY_SEPARATOR === '\\');

            if (!is_dir($modsDir)) {
                fwrite(STDERR, "[ERROR] No modules/ directory.\n");
                exit(1);
            }
            @mkdir($pubRoot, 0775, true);

            // ✅ Important: SELF_FIRST pour voir aussi les dossiers (dont "public")
            $rii = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($modsDir, FilesystemIterator::SKIP_DOTS),
                RecursiveIteratorIterator::SELF_FIRST
            );

            $published = [];

            foreach ($rii as $file) {
                if (!$file->isDir() || strtolower($file->getFilename()) !== 'public') {
                    continue;
                }

                $modPublic  = $file->getPathname();                                           // .../modules/Vendor/Package/public
                $packageDir = dirname($modPublic);                                            // .../modules/Vendor/Package
                $rel        = str_replace($modsDir . DIRECTORY_SEPARATOR, '', $packageDir);   // Vendor/Package
                $targetDir  = $pubRoot . '/' . $rel;                                          // .../public/modules/Vendor/Package
                @mkdir(dirname($targetDir), 0775, true);

                // --force : supprimer lien/dossier existant mal pointé
                if ($force && (is_link($targetDir) || is_dir($targetDir))) {
                    $rmCmd = sprintf('rm -rf %s', escapeshellarg($targetDir));
                    if ($isWindows) {
                        $rmCmd = 'powershell -Command "Remove-Item -Recurse -Force ' . str_replace('"', '\"', $targetDir) . '"';
                    }
                    exec($rmCmd, $_, $rmCode);
                    if ($rmCode !== 0 && file_exists($targetDir)) {
                        echo "[warn] Could not remove existing: $targetDir\n";
                    }
                }

                if (is_link($targetDir) || is_dir($targetDir)) {
                    echo "[skip] $targetDir\n";
                    continue;
                }

                // Stratégie : symlink par défaut (rapide), sinon copie
                $doCopy = $copy || $isWindows;

                if (!$doCopy) {
                    // Lien relatif: .../public/modules/Vendor/Package -> ../../../modules/Vendor/Package/public
                    $relative = '../../../modules/' . $rel . '/public';
                    if (@symlink($relative, $targetDir)) {
                        echo "[link] $targetDir -> $relative\n";
                        $published[] = $rel;
                        continue;
                    }
                    // symlink impossible → on bascule en copie
                    $doCopy = true;
                }

                // Copie récursive (essai via cp -R, sinon fallback PHP)
                $copied = false;

                // 1) cp -R (rapide si dispo)
                $cpCmd = sprintf('cp -R %s %s', escapeshellarg($modPublic), escapeshellarg($targetDir));
                exec($cpCmd, $_, $cpCode);
                if ($cpCode === 0 && is_dir($targetDir)) {
                    echo "[copy] $targetDir\n";
                    $published[] = $rel;
                    $copied = true;
                }

                // 2) Fallback pur PHP (sans getSubPathName)
                if (!$copied) {
                    /** @var \RecursiveIteratorIterator<\RecursiveDirectoryIterator> $it */
                    $it = new RecursiveIteratorIterator(
                        new RecursiveDirectoryIterator($modPublic, FilesystemIterator::SKIP_DOTS),
                        RecursiveIteratorIterator::SELF_FIRST
                    );

                    @mkdir($targetDir, 0775, true);

                    $base = rtrim($modPublic, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
                    $baseLen = strlen($base);

                    foreach ($it as $src) {
                        /** @var \SplFileInfo $src */
                        $full    = $src->getPathname();
                        // chemin relatif depuis .../public/
                        $subPath = substr($full, $baseLen);
                        $dest    = $targetDir . DIRECTORY_SEPARATOR . $subPath;

                        if ($src->isDir()) {
                            @mkdir($dest, 0775, true);
                        } else {
                            @mkdir(dirname($dest), 0775, true);
                            @copy($full, $dest);
                        }
                    }

                    if (is_dir($targetDir)) {
                        echo "[copy] $targetDir (php)\n";
                        $published[] = $rel;
                    } else {
                        echo "[error] failed to publish $rel\n";
                    }
                }
            }

            echo "Published: " . ($published ? implode(', ', $published) : '(none)') . PHP_EOL;
            exit(0);
        }

        // ivi deploy [--dev] [--force] [--no-install]
        if ($cmd === 'deploy') {
            $baseDir = realpath(__DIR__ . '/..') ?: dirname(__DIR__);
            $phpBin  = PHP_BINARY ?: 'php';

            $useDev  = in_array('--dev', $argv, true);        // installer require-dev aussi
            $force   = in_array('--force', $argv, true);      // forcer la republie des assets
            $noInst  = in_array('--no-install', $argv, true); // sauter l'étape composer install

            // Détection de composer (global ou local .phar)
            $composer = trim((string) @shell_exec('command -v composer')) ?: '';
            if ($composer === '' || !is_executable($composer)) {
                $composerPhar = $baseDir . '/composer.phar';
                if (is_file($composerPhar)) {
                    $composer = $phpBin . ' ' . escapeshellarg($composerPhar);
                } else {
                    echo self::badge('WARN', 'yellow') . " Composer not found. Skipping install.\n";
                    $noInst = true;
                }
            }

            // 0) .env minimal si absent (facultatif)
            $envFile = $baseDir . '/.env';
            $envEx   = $baseDir . '/.env.example';
            if (!is_file($envFile) && is_file($envEx)) {
                @copy($envEx, $envFile);
                echo self::badge('IVI', 'cyan') . " Copied .env from .env.example\n";
            }

            // 1) Composer install (sauf --no-install)
            if (!$noInst) {
                $flags = [
                    '--prefer-dist',
                    '--optimize-autoloader',
                    '--no-interaction',
                    '--no-progress',
                ];
                if (!$useDev) {
                    $flags[] = '--no-dev';
                }

                $cmdLine = $composer . ' install ' . implode(' ', $flags);
                echo self::badge('IVI', 'cyan') . " Composer install\n";
                passthru($cmdLine, $code);
                if ($code !== 0) {
                    echo self::badge('ERROR', 'red') . " composer install failed (code $code)\n";
                    exit($code);
                }

                echo self::badge('IVI', 'cyan') . " Composer dump-autoload -o\n";
                passthru($composer . ' dump-autoload -o', $code);
                if ($code !== 0) {
                    echo self::badge('ERROR', 'red') . " composer dump-autoload failed (code $code)\n";
                    exit($code);
                }
            }

            // 2) Publication des assets modules (copie physique, compatible mutualisé)
            $pubFlags = ['modules:publish-assets', '--copy'];
            if ($force) {
                $pubFlags[] = '--force';
            }
            echo self::badge('IVI', 'cyan') . " Publish module assets (" . implode(' ', $pubFlags) . ")\n";
            passthru($phpBin . ' ' . escapeshellarg($baseDir . '/bin/ivi') . ' ' . implode(' ', $pubFlags), $code);
            if ($code !== 0) {
                echo self::badge('ERROR', 'red') . " assets publish failed (code $code)\n";
                exit($code);
            }

            // 3) Petite vérif basique d’accessibilité (facultatif)
            $pubDir = $baseDir . '/public/modules';
            if (is_dir($pubDir)) {
                echo self::badge('OK', 'green') . " Public modules ready: {$pubDir}\n";
            } else {
                echo self::badge('WARN', 'yellow') . " Public modules directory missing: {$pubDir}\n";
            }

            echo self::badge('DONE', 'green') . " Deploy finished.\n";
            echo self::badge('TIP', 'yellow') . " Serve locally: php -S 127.0.0.1:8000 -t public\n";
            exit(0);
        }

        // ivi serve:run [--host=127.0.0.1] [--port=8000] [--docroot=public]
        if ($cmd === 'serve:run') {
            /**
             * ============================================================================
             * Ivi — Dev Server (serve:run)
             * ============================================================================
             *
             * Smart dev server that prefers the caller's project (CWD) over the global
             * Composer package. If it finds a valid app (public/index.php) in the current
             * working directory, it serves that. Otherwise, it falls back to the global
             * package docroot. Users can always override with --docroot=...
             *
             * Order of resolution (docroot):
             *  1) Explicit --docroot=... (if provided and valid)
             *  2) Current working directory/public  (if contains index.php)
             *  3) Parent of CWD/public              (useful when run from ./bin)
             *  4) Package baseDir/public            (global fallback)
             *
             * Notes:
             *  - Prints which docroot is chosen and why.
             *  - Keeps classic flags: --host, --port, --docroot
             * ============================================================================
             */

            // Package base (global fallback)
            $packageBase = realpath(__DIR__ . '/..') ?: dirname(__DIR__);

            // Defaults
            $host = '127.0.0.1';
            $port = '8000';
            $docroot = null;
            $reason  = '';

            // Parse options
            foreach (array_slice($argv, 2) as $arg) {
                if (str_starts_with($arg, '--host=')) {
                    $host = substr($arg, 7);
                } elseif (str_starts_with($arg, '--port=')) {
                    $port = substr($arg, 7);
                } elseif (str_starts_with($arg, '--docroot=')) {
                    $candidate = realpath(substr($arg, 10));
                    if ($candidate && is_dir($candidate)) {
                        $docroot = $candidate;
                        $reason  = 'explicit --docroot';
                    }
                }
            }

            // Helper to validate a docroot (must have index.php)
            $isValidDocroot = static function (string $path): bool {
                return is_dir($path) && is_file(rtrim($path, '/\\') . '/index.php');
            };

            // Auto-detect only if --docroot not provided or invalid
            if ($docroot === null || !$isValidDocroot($docroot)) {
                $cwd = getcwd() ?: '.';

                $candidates = [
                    [$cwd . '/public',            'CWD/public'],
                    [dirname($cwd) . '/public',   'parent/public'],  // useful if run from ./bin
                    [$packageBase . '/public',    'global package fallback'],
                ];

                foreach ($candidates as [$path, $why]) {
                    $real = realpath($path) ?: $path;
                    if ($isValidDocroot($real)) {
                        $docroot = $real;
                        $reason  = $why;
                        break;
                    }
                }
            }

            if (!$docroot) {
                echo self::badge('ERROR', 'red') . " No valid docroot found.\n";
                echo "Tried current project and global package.\n";
                echo "Tip: run from your app root (where public/index.php exists) or pass --docroot=/path/to/public\n";
                exit(1);
            }

            $url = "http://{$host}:{$port}";
            echo self::badge('IVI', 'cyan') . " Serving {$docroot}\n";
            echo self::badge('OK', 'green') . " Running on {$url}\n";
            echo self::badge('TIP', 'yellow') . " Chosen via: {$reason}\n";
            echo self::badge('TIP', 'yellow') . " Stop with Ctrl+C\n\n";

            // Native PHP server command
            $cmdLine = sprintf(
                '%s -S %s:%s -t %s',
                escapeshellcmd(PHP_BINARY),
                escapeshellarg($host),
                escapeshellarg($port),
                escapeshellarg($docroot)
            );

            passthru($cmdLine);
            exit(0);
        }


        // fallback: internal commands
        (new CommandRunner())->run($argv);
    }
}

CliBootstrap::run($argv);
